#! /usr/bin/env bash
set -e

export STELLAR_HOME="/opt/stellar"
export ZABBIXHOME="$STELLAR_HOME/zabbix"
export PGHOME="$STELLAR_HOME/postgresql"
export SUPHOME="$STELLAR_HOME/supervisor"
export COREHOME="$STELLAR_HOME/core"
export HZHOME="$STELLAR_HOME/horizon"

export PGBIN="/usr/lib/postgresql/9.4/bin"
export PGDATA="$PGHOME/data"
export PGUSER="stellar"
export PGPORT=5432

QUICKSTART_INITIALIZED=false
CURRENT_POSTGRES_PID=""
export PGPASSFILE="$PGHOME/.pgpass"

function main() {
	echo ""
	echo "Starting Stellar Quickstart"
	echo ""

	process_args $*

	echo "mode: $STELLAR_MODE"
	echo "network: $NETWORK ($NETWORK_PASSPHRASE)"

	copy_defaults
	init_zabbix_agent
	init_db
	init_stellar_core
	init_horizon
	copy_pgpass

	stop_postgres  # this gets started in init_db

	# launch services
	exec_supervisor
}

function process_args() {
	# getopt --test > /dev/null
	# if [[ $? -ne 4 ]]; then
	#	 echo "I’m sorry, `getopt --test` failed in this environment."
	#	 exit 1
	# fi

	OPTIONS=n:s:
	LONGOPTIONS=network:,zabbix-server:,zabbix-hostname:,seed:,database-host:,core-config:,database-pass:

	PARSED=$(getopt --options=$OPTIONS --longoptions=$LONGOPTIONS --name "$0" -- "$@")
	if [[ $? -ne 0 ]]; then
		exit 2
	fi
	# read getopt’s output this way to handle the quoting right:
	eval set -- "$PARSED"

	while true; do
		case "$1" in
			--database-host)
				DB_HOST="$2"
				shift 2
				;;
            --database-pass)
                POSTGRES_PASSWORD="$2"
				shift 2
				;;
			--core-config)
				CORE_CONFIG="$2"
				shift 2
				;;
			-n|--network)
				NETWORK="$2"
				if [[ $NETWORK != 'testnet' ]] &&
						[[ $NETWORK != 'pubnet' ]] &&
						[[ $NETWORK != 'factury' ]] &&
						[[ $NETWORK != 'standalone' ]]; then
					echo "Expected network to be one of 'testnet', 'pubnet', 'factury' or 'standalone' but got $NETWORK" >&2
					exit 1
				fi
				shift 2
				;;
			--zabbix-server)
				ZABBIX_SERVER="$2"
				shift 2
				;;
			--zabbix-hostname)
				ZABBIX_HOSTNAME="$2"
				shift 2
				;;
			-s|--seed)
				NODE_SEED="$2"
				shift 2
				;;
			--)
				shift
				break
				;;
			*)
				echo "Programming error"
				exit 3
				;;
		esac
	done

	# TODO: ask for what network to use
	if [ -z "$NETWORK" ]; then
		NETWORK="testnet"
	fi
	if [ -z "$DB_HOST" ]; then
		DB_HOST="localhost"
	fi
	if [ -z "$ZABBIX_SERVER" ]; then
		ZABBIX_SERVER="127.0.0.1"
	fi
	if [ -z "$CORE_CONFIG" ]; then
		CORE_CONFIG="stellar-core.cfg"
	fi
	if [ ! -s "/opt/stellar-default/$NETWORK/core/etc/$CORE_CONFIG" ]; then
		echo "Did not find a config file at $NETWORK/core/etc/$CORE_CONFIG" >&2
		exit 2
	fi
	if [ -n "$NODE_SEED" ]; then
		NODE_IS_VALIDATOR=true
	else
		NODE_IS_VALIDATOR=false
	fi

	case "$NETWORK" in
	testnet)
	export NETWORK_PASSPHRASE="Test SDF Network ; September 2015"
	;;
	pubnet)
	export NETWORK_PASSPHRASE="Public Global Stellar Network ; September 2015"
	;;
	factury)
	export NETWORK_PASSPHRASE="FIC Network ; 2018"
	;;
	standalone)
	NETWORK_PASSPHRASE="Standalone Network ; February 2017"
	;;
	*)
		echo "Unknown network: '$NETWORK'" >&2
		exit 1
	esac

	# Are we ephemeral or persistent?
	if [ -z "$STELLAR_MODE" ]; then
		if [ -f "/opt/stellar/.docker-ephemeral" ]; then
			STELLAR_MODE="ephemeral"
		else
			STELLAR_MODE="persistent"
		fi
	fi
}

function set_pg_password() {

	if [ -n "$POSTGRES_PASSWORD" ]; then
		PGPASS=$POSTGRES_PASSWORD
		echo "using POSTGRES_PASSWORD"
		return 0
	fi

	# use a random password when ephemeral (or some other unknown mode)
	if [ "$STELLAR_MODE" != "persistent" ]; then
		PGPASS=$(head /dev/urandom | tr -dc 'a-zA-Z0-9' |  head -c 16)
		echo "postgres password: $PGPASS"
		return 0
	fi

	if [ -n "$PGPASS" ]; then
		echo "postgres password: $PGPASS"
		return 0
	fi

	# ask for a password when persistent
	read -s -p "Enter New Postgresql Password: " PGPASS
	echo ""
	read -s -p "Confirm: " PGPASS_CONFIRMATION
	echo ""

	if [ -z "$PGPASS" ]; then
		echo "Password empty" >&2
		exit 1
	fi

	if [ "$PGPASS" != "$PGPASS_CONFIRMATION" ]; then
		echo "Password mistmach" >&2
		exit 1
	fi

}

function copy_defaults() {
	local CP="rsync -a"

	if [ -d $ZABBIXHOME/etc ]; then
		echo "zabbix: config directory exists, skipping copy"
	else
		$CP /opt/stellar-default/common/zabbix/ $ZABBIXHOME
	fi

	if [ -d $PGHOME/etc ]; then
		echo "postgres: config directory exists, skipping copy"
	else
		$CP /opt/stellar-default/common/postgresql/ $PGHOME
	fi

	if [ -d $SUPHOME/etc ]; then
		echo "supervisor: config directory exists, skipping copy"
	else
		$CP /opt/stellar-default/common/supervisor/ $SUPHOME
	fi

	if [ -d $COREHOME/etc ]; then
		echo "stellar-core: config directory exists, skipping copy"
	else
		$CP /opt/stellar-default/common/core/ $COREHOME
		$CP /opt/stellar-default/$NETWORK/core/ $COREHOME
	fi

	if [ -d $HZHOME/etc ]; then
		echo "horizon: config directory exists, skipping copy"
	else
		$CP /opt/stellar-default/common/horizon/ $HZHOME
	fi
}

function copy_pgpass() {
	local CP="rsync -a"

	$CP /opt/stellar/postgresql/.pgpass /root/
	chmod 0600 /root/.pgpass

	$CP /opt/stellar/postgresql/.pgpass /home/stellar
	chmod 0600 /home/stellar/.pgpass
	chown stellar:stellar /home/stellar/.pgpass
}

function init_zabbix_agent() {
	if [ -f $ZABBIXHOME/.quickstart-initialized ]; then
		echo "zabbix: already initialized"
		return 0
	fi
	pushd $ZABBIXHOME

	run_silent "chown-zabbix" chown zabbix:zabbix .
	
	if [ -z $ZABBIX_HOSTNAME ]; then
		ZABBIX_HOSTNAME_LINE="# Hostname=Zabbix server"
	else
		ZABBIX_HOSTNAME_LINE="Hostname=$ZABBIX_HOSTNAME"
	fi
	sed -ri \
		-e "s/__ZABBIX_SERVER__/$ZABBIX_SERVER/g" \
		-e "s/__ZABBIX_HOSTNAME_LINE__/$ZABBIX_HOSTNAME_LINE/g" \
		etc/zabbix_agentd.conf

	touch .quickstart-initialized
	popd
}

function init_db() {
	if [ -f $PGHOME/.quickstart-initialized ]; then
		echo "postgres: already initialized"
		return 0
	fi
	pushd $PGHOME

	# workaround!!!! from: https://github.com/nimiq/docker-postgresql93/issues/2
	mkdir /etc/ssl/private-copy; mv /etc/ssl/private/* /etc/ssl/private-copy/; rm -r /etc/ssl/private; mv /etc/ssl/private-copy /etc/ssl/private; chmod -R 0700 /etc/ssl/private; chown -R postgres /etc/ssl/private
	# end workaround

	echo "postgres user: $PGUSER"

	set_pg_password

	run_silent "finalize-pgpass" sed -ri "s/__PGPASS__/$PGPASS/g" /opt/stellar/postgresql/.pgpass
    chmod 0600 /opt/stellar/postgresql/.pgpass
    chown postgres:postgres /opt/stellar/postgresql/.pgpass

    if [[ $DB_HOST != 'localhost' ]]; then
        DB_IS_INITIALIZED=`psql -U postgres -h $DB_HOST -c '\list horizon' | grep horizon | cat`
        if [[ -n "$DB_IS_INITIALIZED" ]]; then
            echo "postgres: already initialized on remote host"
            return 0
        fi
    fi

	mkdir -p $PGDATA
	chown postgres:postgres $PGDATA
	chmod 0700 $PGDATA

    if [ $DB_HOST = 'localhost' ]; then
        run_silent "init-postgres" sudo -u postgres $PGBIN/initdb -D $PGDATA
    fi

	start_postgres
	run_silent "create-horizon-db" createdb -U postgres -h $DB_HOST horizon
	run_silent "create-core-db" createdb -U postgres -h $DB_HOST core
	run_silent "stellar-postgres-user" psql -U postgres -h $DB_HOST <<-SQL
		CREATE USER $PGUSER WITH PASSWORD '$PGPASS';
		GRANT ALL PRIVILEGES ON DATABASE horizon to $PGUSER;
		GRANT ALL PRIVILEGES ON DATABASE core to $PGUSER;
	SQL

	touch .quickstart-initialized
	popd
}

function init_stellar_core() {
	if [ -f $COREHOME/.quickstart-initialized ]; then
		echo "core: already initialized"
		return 0
	fi
	pushd $COREHOME

	run_silent "chown-core" chown stellar:stellar .
	if [ -z $ZABBIX_HOSTNAME ]; then
		NODE_SEED_LINE='# SEED=""'
	else
		NODE_SEED_LINE="SEED=\"$NODE_SEED self\""
	fi
	sed -ri \
		-e "s/__PGPASS__/$PGPASS/g" \
		-e "s/__NODE_SEED_LINE__/$NODE_SEED_LINE/g" \
		-e "s/__DB_HOST__/$DB_HOST/g" \
		-e "s/__NODE_IS_VALIDATOR__/$NODE_IS_VALIDATOR/g" \
		-e "s/__NETWORK__/$NETWORK_PASSPHRASE/g" \
		etc/$CORE_CONFIG

	start_postgres

    if [[ $DB_HOST != 'localhost' ]]; then
        CORE_IS_INITIALIZED=`psql -U stellar -h $DB_HOST -c '\dt' core | grep accounts | cat`
    fi
    if [[ -n "$CORE_IS_INITIALIZED" ]]; then
        echo "db for stellar core initialized on remote host"
        return 0
    else
        run_silent "init-core-db" sudo -u stellar stellar-core --newdb --conf etc/$CORE_CONFIG
    fi

	if [ "$NETWORK" == "standalone" ]; then
		run_silent "init-core-scp" sudo -u stellar stellar-core --forcescp --conf etc/$CORE_CONFIG
	fi

	touch .quickstart-initialized
	popd
}

function init_horizon() {
	if [ -f $HZHOME/.quickstart-initialized ]; then
		echo "horizon: already initialized"
		return 0
	fi
	pushd $HZHOME

	run_silent "chown-horizon" chown stellar:stellar .
	
	sed -ri \
		-e "s/__PGPASS__/$PGPASS/g" \
		-e "s/__DB_HOST__/$DB_HOST/g" \
		-e "s/__NETWORK__/$NETWORK_PASSPHRASE/g" \
		etc/horizon.env

	start_postgres
    if [[ $DB_HOST != 'localhost' ]]; then
        HORIZON_IS_INITIALIZED=`psql -U stellar -h $DB_HOST -c '\dt' horizon | grep history_accounts | cat`
    fi
    if [[ -n "$HORIZON_IS_INITIALIZED" ]]; then
        echo "db for stellar horizon initialized on remote host"
        return 0
    else
        run_silent "init-horizon-db" sudo -u stellar ./bin/horizon db init
    fi

	touch .quickstart-initialized
	popd
}

function exec_supervisor() {
	echo "starting supervisor"
	exec supervisord -n -c $SUPHOME/etc/supervisord.conf
}

# run_silent is a utility function that runs a command with an abbreviated
# output provided it succeeds.
function run_silent() {
	local LABEL=$1
	shift
	local COMMAND=$1
	shift
	local ARGS=$@
	local OUTFILE="/tmp/run_silent.out"

	echo -n "$LABEL: "
	set +e

	$COMMAND $ARGS &> $OUTFILE

	if [ $? -eq 0 ]; then
	echo "ok"
	else
	  echo "failed!"
		echo ""
		cat $OUTFILE
		exit 1
	fi

	set -e
}

function start_postgres() {
	if [ ! -z "$CURRENT_POSTGRES_PID" ]; then
		return 0
	fi

    if [ $DB_HOST = 'localhost' ]; then
        sudo -u postgres $PGBIN/postgres -D $PGDATA -c config_file=$PGHOME/etc/postgresql.conf &> /dev/null &
        CURRENT_POSTGRES_PID=$!

        while ! psql -U postgres -h $DB_HOST -c 'select 1' &> /dev/null ; do
          echo "Waiting for postgres to be available..."
          sleep 1
        done
    else
        echo "assuming postgres server is started on remote host $DB_HOST"
    fi

	echo "postgres: up"
}

function stop_postgres() {
    if [ $DB_HOST != 'localhost' ]; then
        echo "cannot stop postgres on remote host $DB_HOST"
		return 0
	fi
	if [ -z "$CURRENT_POSTGRES_PID" ]; then
		return 0
	fi

	kill $CURRENT_POSTGRES_PID
	# wait for postgres to die
	while kill -0 "$CURRENT_POSTGRES_PID" &> /dev/null; do
		sleep 0.5
	done
	echo "postgres: down"
}

pushd () {
	command pushd "$@" > /dev/null
}

popd () {
	command popd "$@" > /dev/null
}

main $@
